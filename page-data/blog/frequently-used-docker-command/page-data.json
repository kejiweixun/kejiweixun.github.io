{"componentChunkName":"component---src-template-blog-post-template-js","path":"/blog/frequently-used-docker-command/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>docker 我已经用了一段时间, 还写了好几篇涉及 docker 的文章, 但 docker 有些命令我用得少, 隔一段时间再用又会忘记, 影响工作效率, 所以决定写下来, 一方面加深记忆, 另一方面是当我再忘记时, 可以快速查询使用.</p>\n<h2>docker 命令</h2>\n<h3>docker build</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker build -t image_name:latest <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>根据 Dockerfile 创建一个 docker image, 最后的 <code class=\"language-text\">.</code> 表示当前目录, 当前目录需要包含一个 Dockerfile 文件, <code class=\"language-text\">-t</code> 表示 tag, 后面是这个 docker image 的名称, 这个名称可以选择性地添加标签.</p>\n<h3>docker run</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker run -d -p <span class=\"token number\">8080</span>:80 container_name</code></pre></div>\n<p>run 需要在 build 之后运行，-d 表示在后台运行，-p 绑定端口，8080 是本地端口，80 是 container 监听的端口，所以在本地访问 8080 端口其实就是访问 container 的 80 端口。 </p>\n<p>在 docker-compose.yml 文件中，通过 ports 属性绑定端口，也是 HOST:CONTAINER 的格式。在 Dockerfile 文件中，通过 expose 属性让 container 监听某个端口，但是如果通过 docker run -p 的方式运行这个 container，那这个 container 会监听 -p 后面的端口，忽略 expose 属性定义的端口。</p>\n<p>-p 可以理解为 docker-compose.yml 文件中的 ports 属性，也可以理解为 publish。</p>\n<p>写在 Dockerfile 中的 <a href=\"https://docs.docker.com/engine/reference/builder/#expose\">EXPOSE 属性</a>更多地充当书明文档的作用，容器制作者通过这个属性告诉容器使用者这个容器希望暴露的端口是什么(代码中的端口是什么)，但并没有 publish 出去。</p>\n<blockquote>\n<p>The EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published. To actually publish the port when running the container, use the -p flag on docker run to publish and map one or more ports, or the -P flag to publish all exposed ports and map them to high-order ports.</p>\n</blockquote>\n<p>写在 docker-compose.yml 文件中的 <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v3/#expose\">expose 属性</a>定义的端口也没有 publish 出去，但可以用来和其他 service 进行通信，要 publish 端口，需要用 <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v3/#ports\">ports 属性</a>。</p>\n<h3>docker save</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker save -o ~/Desktop/docker_image image_name</code></pre></div>\n<p>把一个叫 image_name 的镜像导出为 tar 归档文件, 并保存在桌面, 后面可以接多个镜像名称.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker save image_name <span class=\"token operator\">|</span> <span class=\"token function\">gzip</span> <span class=\"token operator\">></span> ~/Desktop/docker_image_zip</code></pre></div>\n<p>把镜像导出, 并通过 gzip 压缩使其体积变小.</p>\n<h3>docker load</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker load -i ~/Desktop/docker_image</code></pre></div>\n<p><code class=\"language-text\">docker save</code> 出来的文件可以通过 \bload 命令读取, 可以 load 压缩过或没有压缩过的镜像文件.</p>\n<h3>docker logs</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs container_name</code></pre></div>\n<p>读取一个叫 container_name 的容器的日志记录, 会展示从开始运行到现在的所有日志, 如果日志很多, 可能不容易查找到自己需要的信息.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs -f container_name</code></pre></div>\n<p>增加一个 <code class=\"language-text\">-f</code> 选项, 可以让日志实时显示在终端, f 的意思是 follow.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs --since <span class=\"token number\">2020</span>-08-19T09:00:00 --until <span class=\"token number\">2020</span>-08-19T10:00:00 container_name</code></pre></div>\n<p>通过 since 和 until 可以查看某个区间的日志, 时间采用 ISO 8601 Extended 格式.</p>\n<h3>docker exec</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token builtin class-name\">exec</span> -it container_name /bin/bash\ndocker <span class=\"token builtin class-name\">exec</span> -it container_name /bin/sh</code></pre></div>\n<p>有时候是 <code class=\"language-text\">/bin/bash</code> 有时候是 \u001f<code class=\"language-text\">/bin/sh</code>, 作用是进入 container_name 这个容器.</p>\n<h3>docker cp</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">cp</span> container_name:/path/to/the/file/you/want/to/copy <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>把 docker container 中的文件复制到本地, 如果不确定 container 的文件路径, 可以用 <code class=\"language-text\">docker exec</code> 进入 container 确认一下.</p>\n<h3>docker system prune</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker system prune</code></pre></div>\n<p>删除所有没有使用的 container, network, images 等, 这些东西可能会占据很多硬盘空间.</p>\n<h3>docker ps</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">ps</span>\ndocker container <span class=\"token function\">ls</span></code></pre></div>\n<p>一样的, 都是列出所有 container, <code class=\"language-text\">docker images</code> 就是列出所有 image.</p>\n<h2>docker-compose 命令</h2>\n<h3>up</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose up -d</code></pre></div>\n<p>执行这条命令会自动在当前目录寻找一个叫 <code class=\"language-text\">docker-compose.yml</code> 的文件, <code class=\"language-text\">up</code> 的意思是运行这个文件里声明的所有容器, <code class=\"language-text\">-d</code> 意思是在后台运行这些容器, 它是 detach 的简称.</p>\n<p>如果你的 yml 文件不叫 <code class=\"language-text\">docker-compose.yml</code>, 可以通过 <code class=\"language-text\">-f</code> 指定 yml 文件:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose -f another-docker-compose.yml up -d</code></pre></div>\n<p>如果你只是希望运行 <code class=\"language-text\">docker-compose.yml</code> 文件中声明的某个容器, 可以:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose  up -d container_name</code></pre></div>\n<p><code class=\"language-text\">docker-compose up</code> 不同于 <code class=\"language-text\">docker run</code>, 在更新一个容器时, 前者不需要先停止这个容器, 只需要重新 up 一次, 后者需要先停止这个容器, 然后再 run 一次.</p>\n<h3>down</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose down</code></pre></div>\n<p>暂停并移除 <code class=\"language-text\">docker-compose.yml</code> 文件中声明的所有容器, 这样 <code class=\"language-text\">docker ps</code> 的清单就看不到这些容器了.</p>\n<h3>logs</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose logs container_name</code></pre></div>\n<p>如果后面没有加 container_name, 就显示所有容器的 logs, 可以加 <code class=\"language-text\">-f</code> 实时显示.</p>","frontmatter":{"title":"我常用的 docker 和 docker-compose 命令","date":"2020/08/19","slug":"frequently-used-docker-command","description":null}}}]}},"pageContext":{"slug":"frequently-used-docker-command"}},"staticQueryHashes":["1518281631"]}