{"componentChunkName":"component---src-template-blog-post-template-js","path":"/blog/frequently-used-docker-command/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>docker 我已经用了一段时间, 还写了好几篇涉及 docker 的文章, 但 docker 有些命令我用得少, 隔一段时间再用又会忘记, 影响工作效率, 所以决定写下来, 一方面加深记忆, 另一方面是当我再忘记时, 可以快速查询使用.</p>\n<h2>docker 命令</h2>\n<h3>docker build</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker build -t image_name:latest <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>根据 Dockerfile 创建一个 docker image, 最后的 <code class=\"language-text\">.</code> 表示当前目录, 当前目录需要包含一个 Dockerfile 文件, <code class=\"language-text\">-t</code> 表示 tag, 后面是这个 docker image 的名称, 这个名称可以选择性地添加标签.</p>\n<h3>docker save</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker save -o ~/Desktop/docker_image image_name</code></pre></div>\n<p>把一个叫 image_name 的镜像导出为 tar 归档文件, 并保存在桌面, 后面可以接多个镜像名称.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker save image_name <span class=\"token operator\">|</span> <span class=\"token function\">gzip</span> <span class=\"token operator\">></span> ~/Desktop/docker_image_zip</code></pre></div>\n<p>把镜像导出, 并通过 gzip 压缩使其体积变小.</p>\n<h3>docker load</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker load -i ~/Desktop/docker_image</code></pre></div>\n<p><code class=\"language-text\">docker save</code> 出来的文件可以通过 \bload 命令读取, 可以 load 压缩过或没有压缩过的镜像文件.</p>\n<h3>docker logs</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs container_name</code></pre></div>\n<p>读取一个叫 container_name 的容器的日志记录, 会展示从开始运行到现在的所有日志, 如果日志很多, 可能不容易查找到自己需要的信息.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs -f container_name</code></pre></div>\n<p>增加一个 <code class=\"language-text\">-f</code> 选项, 可以让日志实时显示在终端, f 的意思是 follow.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker logs --since <span class=\"token number\">2020</span>-08-19T09:00:00 --until <span class=\"token number\">2020</span>-08-19T10:00:00 container_name</code></pre></div>\n<p>通过 since 和 until 可以查看某个区间的日志, 时间采用 ISO 8601 Extended 格式.</p>\n<h3>docker exec</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token builtin class-name\">exec</span> -it container_name /bin/bash\ndocker <span class=\"token builtin class-name\">exec</span> -it container_name /bin/sh</code></pre></div>\n<p>有时候是 <code class=\"language-text\">/bin/bash</code> 有时候是 \u001f<code class=\"language-text\">/bin/sh</code>, 作用是进入 container_name 这个容器.</p>\n<h3>docker cp</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">cp</span> container_name:/path/to/the/file/you/want/to/copy <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>把 docker container 中的文件复制到本地, 如果不确定 container 的文件路径, 可以用 <code class=\"language-text\">docker exec</code> 进入 container 确认一下.</p>\n<h3>docker system prune</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker system prune</code></pre></div>\n<p>删除所有没有使用的 container, network, images 等, 这些东西可能会占据很多硬盘空间.</p>\n<h3>docker ps</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker <span class=\"token function\">ps</span>\ndocker container <span class=\"token function\">ls</span></code></pre></div>\n<p>一样的, 都是列出所有 container, <code class=\"language-text\">docker images</code> 就是列出所有 image.</p>\n<h2>docker-compose 命令</h2>\n<h3>up</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose up -d</code></pre></div>\n<p>执行这条命令会自动在当前目录寻找一个叫 <code class=\"language-text\">docker-compose.yml</code> 的文件, <code class=\"language-text\">up</code> 的意思是运行这个文件里声明的所有容器, <code class=\"language-text\">-d</code> 意思是在后台运行这些容器, 它是 detach 的简称.</p>\n<p>如果你的 yml 文件不叫 <code class=\"language-text\">docker-compose.yml</code>, 可以通过 <code class=\"language-text\">-f</code> 指定 yml 文件:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose -f another-docker-compose.yml up -d</code></pre></div>\n<p>如果你只是希望运行 <code class=\"language-text\">docker-compose.yml</code> 文件中声明的某个容器, 可以:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose  up -d container_name</code></pre></div>\n<p><code class=\"language-text\">docker-compose up</code> 不同于 <code class=\"language-text\">docker run</code>, 在更新一个容器时, 前者不需要先停止这个容器, 只需要重新 up 一次, 后者需要先停止这个容器, 然后再 run 一次.</p>\n<h3>down</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose down</code></pre></div>\n<p>暂停并移除 <code class=\"language-text\">docker-compose.yml</code> 文件中声明的所有容器, 这样 <code class=\"language-text\">docker ps</code> 的清单就看不到这些容器了.</p>\n<h3>logs</h3>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">docker-compose logs container_name</code></pre></div>\n<p>如果后面没有加 container_name, 就显示所有容器的 logs, 可以加 <code class=\"language-text\">-f</code> 实时显示.</p>","frontmatter":{"title":"我常用的 docker 和 docker-compose 命令","date":"2020/08/19","slug":"frequently-used-docker-command","description":null}}}]}},"pageContext":{"slug":"frequently-used-docker-command"}},"staticQueryHashes":["1518281631"]}